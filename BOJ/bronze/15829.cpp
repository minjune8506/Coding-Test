/**
 * 15829 : Hashing
 * 
 * 해시 함수란 임의의 길이의 입력을 받아서 고정된 길이의 출력을 내보내는 함수로 정의한다.
 * 해시함수는 응용 분야가 많은데 대표적으로 저장과 탐색에 쓰인다.
 * 입력으로 들어오는 문자열에는 영어 소문자로만 구성되어있다고 가정
 * 영어에는 총 26개의 알파벳이 있으므로 a = 1, b = 2, ..., z = 26을 부여할 수 있다.
 * 결과적으로 우리는 하나의 문자열을 수열로 변환할 수 있다.
 * 예를 들어서 문자열 "abba"는 수열 1, 2, 2, 1로 나타낼 수 있다.
 * 
 * 해시 값 계산을 위해 우리는 문자열 혹은 수열을 하나의 정수로 치환하려고 한다.
 * 간단하게 수열을 모두 더하고 적당히 큰 수 M으로 나눠주면 해시함수가 완성이다.
 * 
 * 해시 함수의 입력으로 들어올 수 있는 문자열의 종류는 무한하지만 출력 범위는 정해져 있다.
 * 비둘기 집의 원리 -> 서로 다른 문자열이더라도 동일한 해시 값을 가질 수 있다.
 * 이를 해시 충돌이라고 한다. 좋은 해시 함수는 충돌이 적게 일어나야 한다.
 * 
 * 위의 해시 함수는 충돌이 자주나므로 개선을 해보자.
 * 수열의 각 항마다 고유한 계수를 부여하면된다는 아이디어
 * 항의 번호에 해당하는 만큼 특정한 숫자를 거듭제곱해서 곱해준 다음 더하는 것
 * r 과 M은 서로소인 숫자로 정하는 것이 일반적
 * r은 26보다 큰 소수인 31로 하고, M은 1234567891로 하자.
 * 주어진 문자열의 해시값을 계산
 * 
 * 입력
 * 문자열의 길이 L이 주어진다.
 * 영문 소문자로만 이루어진 문자열이 들어온다.
 * 문자열은 모두 알파벳 소문자로만 구성되어 있다.
 * 
 * 출력
 * 해시함수와 문자열을 사용해 계산한 해시 값을 정수로 출력
 */
// 해시함수를 따라 계산을 하면 31의 지수승을 하다 보면 오버플로우가 발생한다.
// 해결방법 : 모듈러 연산 이용 (Mod의 성질)
// 나누기 간에 분배, 결합 법칙이 성립한다.
#include <iostream>
#include <vector>
#include <cmath>

#define M 1234567891
using namespace std;

int L;

int main(void)
{
	vector<int> seq;

	cin >> L;
	for (int i = 0 ; i < L ; i++)
	{
		char ch;

		cin >> ch;
		seq.push_back(ch - 'a' + 1);
	}
	long long r = 1;
	long long sum = 0;
	for (int i = 0 ; i < L ; i++)
	{
		sum += (seq[i] * r);
		if (sum > M)
			sum %= M;
		r = r * 31 % M;
	}
	cout << sum << '\n';
}
